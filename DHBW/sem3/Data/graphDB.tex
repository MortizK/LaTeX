\documentclass[a4paper]{article}

\input{../preamble.tex}

%% For Big Tables
\usepackage{tabulary}
\usepackage{booktabs}

%% For Horizontal Page
\usepackage{pdflscape}

%% For code snippets
\usepackage{listings}
\lstset{basicstyle=\ttfamily, frame=single, breaklines=true}

%%% Define languages for
\usepackage{listings}
\lstdefinelanguage{Cypher}{
  keywords={MATCH, RETURN, WHERE, CREATE, MERGE, DELETE, SET},
  sensitive=true,
  morecomment=[l]{//},
  morestring=[b]"
}
\lstdefinelanguage{Gremlin}{
  keywords={g, V, out, has, values},
  sensitive=true,
  morecomment=[l]{//},
  morestring=[b]"
}

\title{Graphenorientierte Datenbanken}
\author{Lars Tröster, Eric Kusterer, Möritz Köhler, Niklas Reusch }

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Einleitung}

In der heutigen Datenwelt steigen sowohl das Volumen als auch die Komplexität der gespeicherten Informationen stetig an. Während relationale Datenbanksysteme über Jahrzehnte den Standard in der Datenverwaltung bildeten, stoßen sie zunehmend an ihre Grenzen, wenn es um hochgradig vernetzte Datenstrukturen geht - etwa soziale Netzwerke, Wissensgraphen oder Betrugserkennungssysteme.

Um diesen Anforderungen gerecht zu werden, haben sich neben den klassischen relationalen Systemen verschiedene alternative Datenbankmodelle entwickelt. Eines der bedeutendsten darunter ist das graphenorientierte Datenbanksystem (Graph DBMS). Ziel dieser Ausarbeitung ist es, diese Klassifizierung näher zu beschreiben, ihre Merkmale und Einsatzgebiete darzustellen sowie führende Produkte zu analysieren und zu vergleichen, um Anwendern eine fundierte Entscheidungsgrundlage zu bieten.

\section{Klassifizierung von Datenbankensystemen}

Datenbanksysteme lassen sich grundsätzlich danach klassifizieren, wie sie Daten speichern, organisieren und abfragen. Die wichtigsten Klassen sind:

\begin{itemize}
    \item \textbf{Relationale DBMS} (z. B. MySQL, PostgreSQL): Daten werden in Tabellen mit festen Schemata gespeichert. Beziehungen zwischen Entitäten werden über Fremdschlüssel definiert.
    \item \textbf{Dokumentenorientierte DBMS} (z. B. MongoDB, Couchbase): Speicherung semi-strukturierter Daten (z. B. JSON-Dokumente) mit hoher Flexibilität.
    \item \textbf{Key-Value-Stores} (z. B. Redis, DynamoDB): Daten werden als Schlüssel-Wert-Paare ohne feste Struktur abgelegt, sehr performant für einfache Zugriffe.
    \item \textbf{Spaltenorientierte DBMS}(z. B. Cassandra, HBase): Optimiert für analytische Abfragen über große Datenmengen.
    \item \textbf{Graphenorientierte DBMS} (z. B. Neo4j, TigerGraph): Daten werden als Knoten (Entities) und Kanten (Beziehungen) modelliert und gespeichert.

\end{itemize}

Graphenorientierte Systeme bilden also eine eigene Klasse von NoSQL-Datenbanken. Ihr zentrales Merkmal ist, dass sie Beziehungen als erstklassige Objekte behandeln und dadurch komplexe Netzwerke effizient darstellen können.

\section{Grundlagen graphenorientierte DBMS}

Graphdatenbanken basieren auf der mathematischen Graphentheorie. Daten werden nicht in Tabellen, sondern in Graphenstrukturen abgelegt, die aus Knoten (Nodes), Kanten (Edges) und optionalen Eigenschaften (Properties) bestehen.

\begin{itemize}
    \item \textbf{Knoten} repräsentieren Entitäten (z.\,B. Personen, Orte, Produkte).
    \item \textbf{Kanten} stellen Beziehungen zwischen diesen Entitäten dar (z.\,B. kennt, kauft, arbeitet für).
    \item \textbf{Eigenschaften} sind Schlüssel-Wert-Paare, die zusätzliche Informationen speichern (z.\,B. Alter, Datum, Gewichtung).
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\linewidth]{fig/Soziogramm.png}
    \caption{Darstellung eines Soziogramms.}
    \label{fig:soziogramm}
\end{figure}

Es existieren zwei dominante Graphmodelle:

\begin{itemize}
    \item \textbf{Property-Graph-Modell} (z.\,B. Neo4j, TigerGraph): Knoten und Kanten besitzen beliebige Eigenschaften, z.\,B. \texttt{Name: Alice}, \texttt{Gewicht: 10kg}, \texttt{Farbe: Rot}.
    \item \textbf{RDF-Modell} (Resource Description Framework) (z.\,B. Blazegraph, Amazon Neptune): Daten werden als Tripel "Subjekt-Prädikat-Objekt" dargestellt, z.\,B. \texttt{Alice --kennt-> Bob}.
\end{itemize}

Ein wesentliches Merkmal ist die \textbf{Graphtraversierung} - das gezielte Durchlaufen von Kanten zur Analyse komplexer Beziehungsnetzwerke. Zur Abfrage von Graphdaten existieren spezialisierte Sprachen:

\begin{itemize}
    \item \textbf{Cypher} (Neo4j) - deklarativ, SQL-ähnlich:
    \begin{lstlisting}[language=Cypher,basicstyle=\ttfamily\small]
MATCH (p1:Person)-[:KENNT]->(p2:Person),
      (p1)-[:KAUFT]->(prod:Produkt),
      (p2)-[:KAUFT]->(prod)
RETURN p1.name, p2.name, prod.name;
    \end{lstlisting}

    \item \textbf{Gremlin} (Microsoft Azure Cosmos DB) - prozedural:
    \begin{lstlisting}[language=Gremlin,basicstyle=\ttfamily\small]
g.V().has('person','name','Alice')
  .as('p1')
  .out('kennt').as('p2')
  .out('kauft').as('prod')
  .in('kauft').where(eq('p2'))
  .select('p1','p2','prod').by('name')
    \end{lstlisting}

    \item \textbf{GQL} - internationaler Standard für Graphabfragen:
    GQL ist derzeit stark an Cypher angelehnt, weshalb die Syntax in diesem Beispiel identisch ist:
    \begin{lstlisting}[language=Cypher,basicstyle=\ttfamily\small]
MATCH (p1:Person)-[:KENNT]->(p2:Person),
      (p1)-[:KAUFT]->(prod:Produkt),
      (p2)-[:KAUFT]->(prod)
RETURN p1.name, p2.name, prod.name;
    \end{lstlisting}

    \item \textbf{SPARQL} (GraphDB) - Standard für RDF-basierte Graphen:
    \begin{lstlisting}[language=SPARQL,basicstyle=\ttfamily\small]
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://example.com/schema#>

SELECT ?p1 ?p2 ?prod
WHERE {
  ?p1 foaf:name "Alice" .
  ?p1 ex:kennt ?p2 .
  ?p1 ex:kauft ?prod .
  ?p2 ex:kauft ?prod .
}
    \end{lstlisting}
\end{itemize}

Alle Abfragen geben das Gleiche zurück.

Graphdatenbanken sind somit ideal geeignet, wenn Beziehungen selbst einen hohen Informationswert besitzen und nicht nur als Verknüpfung verstanden werden.

\section{Merkmale und Einsatzgebiete}

Graphdatenbanken zeichnen sich durch folgende Hauptmerkmale aus:

\begin{itemize}
    \item \textbf{Hohe Performance bei Beziehungsabfragen:} Abfragen über viele Beziehungen (z. B. "Freunde von Freunden") lassen sich effizient ausführen, da Beziehungen direkt gespeichert werden.
    \item \textbf{Flexibles Schema:} Neue Knotentypen oder Eigenschaften können ohne Schemaänderungen hinzugefügt werden.
    \item \textbf{Intuitive Modellierung:} Beziehungen entsprechen der realen Denkweise über Netzwerke.
    \item \textbf{Skalierbarkeit:} Moderne Systeme unterstützen horizontale Skalierung über Cluster.
    \item \textbf{Visuelle Darstellbarkeit:} Graphstrukturen lassen sich leicht visualisieren und analysieren.
\end{itemize}

Typische Einsatzgebiete sind:

\begin{itemize}
    \item Soziale Netzwerke (z. B. Verbindungen, Interessen, Gruppen)
    \item Empfehlungssysteme (z. B. "Nutzer, die X mögen, mögen auch Y")
    \item Betrugserkennung (z. B. auffällige Transaktionsmuster)
    \item Wissensgraphen und Ontologien
    \item Netzwerkanalyse (z. B. Telekommunikation, IT-Systeme)
\end{itemize}


\begin{landscape}

\section{Vergleich ausgewählter Graph DBMS}

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.3}
\setlength{\tabcolsep}{5pt}

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|}
\hline
\textbf{Produkt} & \textbf{Hersteller} & \textbf{Erscheinungsjahr} & \textbf{Abfragesprache} & \textbf{Marktverbreitung} & \textbf{Stärken / Schwächen} \\ \hline
\textbf{Neo4j} & Neo4j & 2007 & Cypher & 45-50\% & \textbf{Stärken:} ACID-konform, intuitive Modellierung. \textbf{Schwächen:} Hohe Kosten bei Enterprise, nicht für RDF geeignet \\ \hline
\textbf{Microsoft Azure Cosmos DB} & Microsoft & 2017 & Gremlin & 12\% & \textbf{Stärken:} Cloud-Dienst, automatische Skalierung und Replikation. \textbf{Schwächen:} Nur in Azure, begrenzte Graph-Funktionalität \\ \hline
\textbf{OrientDB} & SAP SE & 2011 & SQL-ähnlich & 9\% & \textbf{Stärken:} ACID-konform, Multi-Modell (Dokument, Objekt, Graph). \textbf{Schwächen:} Schlechte Performance bei großen Graphen \\ \hline
\textbf{ArangoDB} & ArangoDB & 2011 & AQL & 7\% & \textbf{Stärken:} Multi-Modell (Dokument, Key-Value, Graph), skalierbar über Cluster. \textbf{Schwächen:} Komplexe Abfragesprache \\ \hline
\textbf{Amazon Neptune} & Amazon Web Services & 2017 & Gremlin (LPG), SPARQL 1.1 (RDF) & 6\% & \textbf{Stärken:} Skalierbarer Cloud-Dienst, unterstützt RDF und LPG. \textbf{Schwächen:} Nur AWS, Kosten steigen bei großen Datenmengen \\ \hline
\textbf{GraphDB} & Ontotext AD & 2004 & SPARQL 1.1 & 3-4\% & \textbf{Stärken:} W3C-konformes RDF-Modell, automatisches Reasoning. \textbf{Schwächen:} Komplexe Modellierung, begrenzte Performance bei großen Datenmengen \\ \hline
\end{tabulary}

\caption{Vergleich verschiedener Graphdatenbanken hinsichtlich Hersteller, Erscheinungsjahr, Abfragesprache, Marktverbreitung sowie Stärken und Schwächen.}
\end{table}
\end{landscape}

\section{Bewertung und Gegenüberstellung}

Die vorgestellten Graphdatenbanken unterscheiden sich vor allem in Funktionsumfang, Skalierbarkeit, Marktverbreitung und Integrationsmöglichkeiten. Eine Bewertung zeigt:

\begin{itemize}
    \item \textbf{Neo4j} ist nach wie vor der Marktführer (45-50\%) und überzeugt durch ACID-Konformität und intuitive Netzwerkmodellierung. Ideal für Forschung, Prototypen und produktive Anwendungen. Einschränkung: Hohe Kosten bei der Enterprise Edition und keine native RDF-Unterstützung.
    
    \item \textbf{Microsoft Azure Cosmos DB} bietet als Cloud-Dienst automatische Skalierung und Replikation, jedoch ist die Nutzung auf Microsoft Azure beschränkt und die Graph-Funktionalität begrenzt. Marktanteil: ca. 12\%.
    
    \item \textbf{OrientDB} kombiniert Dokument-, Objekt- und Graphmodelle (Multi-Modell) und ist ACID-konform. Nachteile sind die eingeschränkte Performance bei großen Graphen. Marktanteil: 9\%.
    
    \item \textbf{ArangoDB} überzeugt durch Multi-Modell-Funktionalität (Dokument, Key-Value, Graph) und Skalierbarkeit über Cluster und Sharding. Die komplexe Abfragesprache erschwert jedoch den Einstieg. Marktanteil: 7\%.
    
    \item \textbf{Amazon Neptune} unterstützt sowohl RDF- als auch Property-Graphen (Gremlin, SPARQL 1.1) und ist stark cloud-integriert. Einschränkungen: Nutzung nur in AWS und steigende Kosten bei großen Datenmengen. Marktanteil: 6\%.
    
    \item \textbf{GraphDB} ist ein RDF-orientiertes System mit W3C-konformem Modell und automatischem Reasoning. Nachteile sind die komplexe Modellierung und begrenzte Performance bei großen Datenmengen. Marktanteil: 3-4\%.
\end{itemize}

\section{Zusammenfassung und Empfehlung}

Graphenorientierte Datenbanksysteme bieten eine effiziente Möglichkeit, komplexe Beziehungen zwischen Daten abzubilden und zu analysieren. Sie unterscheiden sich grundlegend von relationalen Modellen, da Beziehungen als erstklassige Entitäten behandelt werden.

Für viele moderne Anwendungsfälle – insbesondere in der Datenanalyse, im Machine Learning oder in der Netzwerksicherheit – sind Graphdatenbanken heute unverzichtbar. Neo4j ist derzeit der Branchenstandard, während TigerGraph und Amazon Neptune leistungsstarke Alternativen im Enterprise-Umfeld darstellen. Wer Open Source und Flexibilität bevorzugt, ist mit ArangoDB, OrientDB oder JanusGraph gut beraten. GraphDB eignet sich besonders für RDF-basierte Wissensgraphen.

Fazit zur Wahl der Graphdatenbank:

\begin{itemize}
    \item \textbf{Für schnelle Entwicklung und Prototypen:} Neo4j oder ArangoDB
    \item \textbf{Für Cloud-native Anwendungen:} Amazon Neptune oder Azure Cosmos DB
    \item \textbf{Für große, verteilte Unternehmensprojekte:} Neo4j Enterprise oder ArangoDB Cluster
    \item \textbf{Für RDF-basierte Wissensgraphen:} GraphDB
    \item \textbf{Für Multi-Modell-Ansätze:} ArangoDB oder OrientDB
\end{itemize}

Insgesamt bieten Graphdatenbanken einen klaren Mehrwert für Szenarien mit stark vernetzten Datenstrukturen und sind ein wichtiger Bestandteil moderner Datenarchitekturen. Die Wahl des richtigen Systems hängt vom Einsatzzweck, der vorhandenen Infrastruktur und den Anforderungen an Performance, Skalierbarkeit und Datenmodell ab. Marktführer wie Neo4j bieten eine breite Unterstützung und Community, während spezialisierte Systeme für spezifische Anwendungsfälle die bessere Wahl sein können.


\end{document}