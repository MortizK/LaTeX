\documentclass[a4paper]{article}

\input{../preamble.tex}

%% For Big Tables
\usepackage{tabulary}
\usepackage{booktabs}

%% For Horizontal Page
\usepackage{pdflscape}

%% For code snippets
\usepackage{listings}
\lstset{basicstyle=\ttfamily, frame=single, breaklines=true}

%%% Define languages for
\lstdefinelanguage{Cypher}{
  keywords={MATCH, RETURN, WHERE, CREATE, MERGE, DELETE, SET},
  sensitive=true,
  morecomment=[l]{//},
  morestring=[b]"
}
\lstdefinelanguage{Gremlin}{
  keywords={g, V, out, has, values},
  sensitive=true,
  morecomment=[l]{//},
  morestring=[b]"
}

%% For Margins
\usepackage[margin=2.5cm]{geometry}

\title{
    \includegraphics[width=0.3\textwidth]{fig/DHBWLogo.pdf}\\[1cm]
    Graphenorientierte Datenbanken}
\author{Lars Tröster, Eric Kusterer, Möritz Köhler, Niklas Reusch }

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Einleitung}

Die Menge und Komplexität von Daten wachsen in nahezu allen Bereichen rasant. Klassische relationale Datenbanksysteme haben über Jahrzehnte die Grundlage der Datenverwaltung gebildet, stoßen jedoch bei stark vernetzten Informationen an ihre Grenzen, insbesondere wenn umfangreiche JOIN-Operationen erforderlich sind - wie dies etwa bei sozialen Netzwerken, Wissensgraphen oder bei der Analyse von Transaktionsnetzwerken zur Betrugserkennung der Fall ist.

Um diese Herausforderungen zu bewältigen, sind alternative Datenbankmodelle entstanden, die speziell für die Verarbeitung hochgradig vernetzter Daten konzipiert sind. Dazu zählen insbesondere graphenorientierte Datenbanksysteme (Graph DBMS), die Beziehungen zwischen Daten als zentrale Elemente betrachten. Ziel dieser Arbeit ist es, die Eigenschaften und Einsatzmöglichkeiten graphenbasierter Systeme darzustellen, führende Produkte zu vergleichen und so eine fundierte Entscheidungsgrundlage für deren Nutzung zu schaffen.

\section{Klassifizierung von Datenbankensystemen}

Datenbanksysteme lassen sich grundsätzlich danach klassifizieren, wie sie Daten speichern, organisieren und abfragen. Die wichtigsten Klassen sind: \cite{kemper2015datenbanksysteme}

\begin{itemize}
    \item \textbf{Relationale DBMS} (z. B. MySQL, PostgreSQL): Daten werden in Tabellen mit festen Schemata gespeichert. Beziehungen zwischen Entitäten werden über Fremdschlüssel definiert.
    \item \textbf{Dokumentenorientierte DBMS} (z. B. MongoDB, Couchbase): Speicherung semi-strukturierter Daten (z. B. JSON-Dokumente) mit hoher Flexibilität.
    \item \textbf{Key-Value-Stores} (z. B. Redis, DynamoDB): Daten werden als Schlüssel-Wert-Paare ohne feste Struktur abgelegt, sehr performant für einfache Zugriffe.
    \item \textbf{Spaltenorientierte DBMS}(z. B. Cassandra, HBase): Optimiert für analytische Abfragen über große Datenmengen.
    \item \textbf{Graphenorientierte DBMS} (z. B. Neo4j): Daten werden als Knoten (Entities) und Kanten (Beziehungen) modelliert und gespeichert.

\end{itemize}

Graphenorientierte Systeme bilden also eine eigene Klasse von NoSQL-Datenbanken. Ihr zentrales Merkmal ist, dass sie Beziehungen als erstklassige Objekte behandeln und dadurch komplexe Netzwerke effizient darstellen können.

\section{Grundlagen graphenorientierte DBMS}

Graphdatenbanken basieren auf der mathematischen Graphentheorie. Daten werden nicht in Tabellen, sondern in Graphenstrukturen abgelegt, die aus Knoten (Nodes), Kanten (Edges) und optionalen Eigenschaften (Properties) bestehen. \cite{robinson2015graphdb,angles2017survey}

\begin{itemize}
    \item \textbf{Knoten} repräsentieren Entitäten (z.\,B. Personen, Orte, Produkte).
    \item \textbf{Kanten} stellen Beziehungen zwischen diesen Entitäten dar (z.\,B. kennt, kauft, arbeitet für).
    \item \textbf{Eigenschaften} sind Schlüssel-Wert-Paare, die zusätzliche Informationen speichern (z.\,B. Alter, Datum, Gewichtung).
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.55\linewidth]{fig/Soziogramm.png}
    \caption{Darstellung eines Soziogramms. \cite{sozio}}
    \label{fig:soziogramm}
\end{figure}

Es existieren zwei dominante Graphmodelle:

\begin{itemize}
    \item \textbf{Property-Graph-Modell} (z.\,B. Neo4j): Knoten und Kanten besitzen beliebige Eigenschaften, z.\,B. \texttt{Name: Alice}, \texttt{Gewicht: 10kg}, \texttt{Farbe: Rot}.
    
    Diese sind besonders für Traversierungen geeignet.\cite{angles2020graph}
    \item \textbf{RDF-Modell} (Resource Description Framework) (z.\,B. Blazegraph, Amazon Neptune): Daten werden als Tripel "Subjekt-Prädikat-Objekt" dargestellt, z.\,B. \texttt{Alice --kennt-> Bob}.
    
    Diese sind für Reasoning und semantische Abfragen geeignet.
\end{itemize}

Ein wesentliches Merkmal ist die Graphtraversierung - das gezielte Durchlaufen von Kanten zur Analyse komplexer Beziehungsnetzwerke. Zur Abfrage von Graphdaten existieren spezialisierte Sprachen:

\begin{itemize}
    \item \textbf{Cypher} (Neo4j) - deklarativ, SQL-ähnlich: \cite{cypher2025}
    \begin{lstlisting}[language=Cypher,basicstyle=\ttfamily\small]
MATCH (p1:Person)-[:KENNT]->(p2:Person),
      (p1)-[:KAUFT]->(prod:Produkt),
      (p2)-[:KAUFT]->(prod)
RETURN p1.name, p2.name, prod.name;
    \end{lstlisting}

    \item \textbf{Gremlin} (Microsoft Azure Cosmos DB) - prozedural: \cite{gremlin2025}
    \begin{lstlisting}[language=Gremlin,basicstyle=\ttfamily\small]
g.V().has('person','name','Alice')
  .as('p1')
  .out('kennt').as('p2')
  .out('kauft').as('prod')
  .in('kauft').where(eq('p2'))
  .select('p1','p2','prod').by('name')
    \end{lstlisting}

    \item \textbf{GQL} - internationaler Standard für Graphabfragen: \cite{gql2025}
    GQL ist derzeit stark an Cypher angelehnt, weshalb die Syntax in diesem Beispiel identisch ist:
    \begin{lstlisting}[language=Cypher,basicstyle=\ttfamily\small]
MATCH (p1:Person)-[:KENNT]->(p2:Person),
      (p1)-[:KAUFT]->(prod:Produkt),
      (p2)-[:KAUFT]->(prod)
RETURN p1.name, p2.name, prod.name;
    \end{lstlisting}
    GQL befindet sich derzeit im Standardisierungsprozess und ist noch nicht vollständig.

    \item \textbf{SPARQL} (GraphDB) - Standard für RDF-basierte Graphen: \cite{sparql2025}
    \begin{lstlisting}[language=SPARQL,basicstyle=\ttfamily\small]
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://example.com/schema#>

SELECT ?p1 ?p2 ?prod
WHERE {
  ?p1 foaf:name "Alice" .
  ?p1 ex:kennt ?p2 .
  ?p1 ex:kauft ?prod .
  ?p2 ex:kauft ?prod .
}
    \end{lstlisting}
    Die Prefixe dienen dazu um URIs in kurzform anzugeben. foaf steht für Friend of a Friend und ex ist hier selbst gewählt um ein Schema zu repräsentierten.
\end{itemize}

Alle Abfragen geben das Gleiche zurück.

Graphdatenbanken sind somit ideal geeignet, wenn Beziehungen selbst einen hohen Informationswert besitzen und nicht nur als Verknüpfung verstanden werden. Wie etwas bei Transaktionspfaden, wo die Transaktion selber viele Informationen speicher.

\section{Merkmale und Einsatzgebiete}

Graphdatenbanken zeichnen sich durch folgende Hauptmerkmale aus:

\begin{itemize}
    \item \textbf{Hohe Performance bei Beziehungsabfragen:} Abfragen über viele Beziehungen (z. B. "Freunde von Freunden") lassen sich effizient ausführen, da Beziehungen direkt gespeichert werden.
    \item \textbf{Flexibles Schema:} Neue Knotentypen oder Eigenschaften können ohne Schemaänderungen hinzugefügt werden.
    \item \textbf{Intuitive Modellierung:} Beziehungen entsprechen der realen Denkweise über Netzwerke.
    \item \textbf{Skalierbarkeit:} Moderne Systeme unterstützen horizontale Skalierung über Cluster.
    \item \textbf{Visuelle Darstellbarkeit:} Graphstrukturen lassen sich leicht visualisieren und analysieren.
\end{itemize}

Typische Einsatzgebiete sind:

\begin{itemize}
    \item Soziale Netzwerke (z. B. Verbindungen, Interessen, Gruppen)
    \item Empfehlungssysteme (z. B. "Nutzer, die X mögen, mögen auch Y")
    \item Betrugserkennung (z. B. Anomalieerkennung in Transaktionsnetzwerken)
    \item Wissensgraphen und Ontologien
    \item Netzwerkanalyse (z. B. Telekommunikation, IT-Systeme)
\end{itemize}


\begin{landscape}

\section{Vergleich ausgewählter Graph DBMS}

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.3}
\setlength{\tabcolsep}{4pt}

\begin{tabulary}{\linewidth}{|L|L|l|L|L|L|L|}
\hline
\textbf{Produkt} 
& \textbf{Hersteller} 
& \textbf{Jahr} 
& \textbf{Abfragesprache} 
& \textbf{Marktanteil} 
& \textbf{Kosten (Stand 2025)} 
& \textbf{Stärken / Schwächen} 
\\ \hline

\textbf{Neo4j} 
& Neo4j 
& 2007 
& Cypher 
& 45--50\% 
& Open Source oder Cloud-Dienst \textit{AuraDB Professional} ab 65€/GB/Monat, Business Critical bis ca. 150€/GB/Monat
& 
\textbf{Stärken:} ACID-konform, intuitive Modellierung. \textbf{Schwächen:} Hohe Kosten bei Enterprise, nicht für RDF geeignet 
\\ \hline

\textbf{Microsoft Azure Cosmos DB} 
& Microsoft 
& 2017 
& Gremlin 
& 12\% 
& Verbrauchsbasiert mit ca. 0,29€ pro Request
& 
\textbf{Stärken:} Cloud-Dienst, automatische Skalierung und Replikation. \textbf{Schwächen:} Nur in Azure, begrenzte Graph-Funktionalität 
\\ \hline

\textbf{OrientDB} 
& SAP SE 
& 2011 
& SQL-ähnlich 
& 9\% 
& Community Edition kostenlos, Enterprise-Lizenz ca. 9.000€, Standard ab 5.500€ 
& 
\textbf{Stärken:} ACID-konform, Multi-Modell (Dokument, Objekt, Graph). \textbf{Schwächen:} Schlechte Performance bei großen Graphen 
\\ \hline

\textbf{ArangoDB} 
& ArangoDB 
& 2011 
& AQL 
& 7\% 
& Community Edition kostenlos, Cloud-/Enterprise-Version auf Anfrage mit 2.000-6.000€
& 
\textbf{Stärken:} Multi-Modell (Dokument, Key-Value, Graph), skalierbar über Cluster. \textbf{Schwächen:} Komplexe Abfragesprache 
\\ \hline

\textbf{Amazon Neptune} 
& Amazon Web Services 
& 2017 
& Gremlin (LPG), SPARQL 1.1 (RDF) 
& 6\% 
& db.r5.large, ca 320€/Monat + Speicher + Anfragen
& 
\textbf{Stärken:} Skalierbarer Cloud-Dienst, unterstützt RDF und LPG. \textbf{Schwächen:} Nur AWS, Kosten steigen bei großen Datenmengen 
\\ \hline

\textbf{GraphDB} 
& Ontotext AD 
& 2004 
& SPARQL 1.1 
& 3--4\% 
& Community Edition kostenlos; Enterprise-Lizenz nur auf Anfrage (1.000-6.000€) 
& 
\textbf{Stärken:} W3C-konformes RDF-Modell, automatisches Reasoning. \textbf{Schwächen:} Komplexe Modellierung, begrenzte Performance bei großen Datenmengen 
\\ \hline

\end{tabulary}

\caption{Erweiterter Vergleich verschiedener Graphdatenbanken hinsichtlich Hersteller, Erscheinungsjahr, Abfragesprache, Marktverbreitung, Kosten sowie Stärken und Schwächen. \cite{neo4j2025,azurecosmosdb2025,orientdb2025,arangodb2025,awsneptune2025,graphdb2025}}
\end{table}

\end{landscape}


\section{Bewertung und Gegenüberstellung}

Die vorgestellten Graphdatenbanken unterscheiden sich vor allem in Funktionsumfang, Skalierbarkeit, Marktverbreitung und Integrationsmöglichkeiten. Eine Bewertung zeigt:

\begin{itemize}
    \item \textbf{Neo4j} ist nach wie vor der Marktführer (45-50\%) und überzeugt durch ACID-Konformität und intuitive Netzwerkmodellierung. Ideal für Forschung, Prototypen und produktive Anwendungen. Einschränkung: Hohe Kosten bei der Enterprise Edition und keine native RDF-Unterstützung.
    
    \item \textbf{Microsoft Azure Cosmos DB} bietet als Cloud-Dienst automatische Skalierung und Replikation, jedoch ist die Nutzung auf Microsoft Azure beschränkt und die Graph-Funktionalität begrenzt. Marktanteil: ca. 12\%.
    
    \item \textbf{OrientDB} kombiniert Dokument-, Objekt- und Graphmodelle (Multi-Modell) und ist ACID-konform. Nachteile sind die eingeschränkte Performance bei großen Graphen. Marktanteil: 9\%.
    
    \item \textbf{ArangoDB} überzeugt durch Multi-Modell-Funktionalität (Dokument, Key-Value, Graph) und Skalierbarkeit über Cluster und Sharding. Die komplexe Abfragesprache erschwert jedoch den Einstieg. Marktanteil: 7\%.
    
    \item \textbf{Amazon Neptune} unterstützt sowohl RDF- als auch Property-Graphen (Gremlin, SPARQL 1.1) und ist stark cloud-integriert. Einschränkungen: Nutzung nur in AWS und steigende Kosten bei großen Datenmengen. Marktanteil: 6\%.
    
    \item \textbf{GraphDB} ist ein RDF-orientiertes System mit W3C-konformem Modell und automatischem Reasoning. Nachteile sind die komplexe Modellierung und begrenzte Performance bei großen Datenmengen. Marktanteil: 3-4\%.
\end{itemize}

\section{Zusammenfassung und Empfehlung}

Graphenorientierte Datenbanksysteme bieten eine effiziente Möglichkeit, komplexe Beziehungen zwischen Daten abzubilden und zu analysieren. Sie unterscheiden sich grundlegend von relationalen Modellen, da Beziehungen als erstklassige Entitäten behandelt werden.

Für viele moderne Anwendungsfälle - insbesondere in der Datenanalyse, im Machine Learning oder in der Netzwerksicherheit - sind Graphdatenbanken heute unverzichtbar. Neo4j ist derzeit der Branchenstandard, während  Amazon Neptune eine leistungsstarke Alternativ im Enterprise-Umfeld darstellt. Wer Open Source und Flexibilität bevorzugt, ist mit ArangoDB oder OrientDB gut beraten. GraphDB eignet sich besonders für RDF-basierte Wissensgraphen.

Fazit zur Wahl der Graphdatenbank:

\begin{itemize}
    \item \textbf{Für schnelle Entwicklung und Prototypen:} Neo4j oder ArangoDB
    \item \textbf{Für Cloud-native Anwendungen:} Amazon Neptune oder Azure Cosmos DB
    \item \textbf{Für große, verteilte Unternehmensprojekte:} Neo4j Enterprise oder ArangoDB Cluster
    \item \textbf{Für RDF-basierte Wissensgraphen:} GraphDB
    \item \textbf{Für Multi-Modell-Ansätze:} ArangoDB oder OrientDB
\end{itemize}

Insgesamt bieten Graphdatenbanken einen klaren Mehrwert für Szenarien mit stark vernetzten Datenstrukturen und sind ein wichtiger Bestandteil moderner Datenarchitekturen. Die Wahl des richtigen Systems hängt vom Einsatzzweck, der vorhandenen Infrastruktur und den Anforderungen an Performance, Skalierbarkeit und Datenmodell ab. Marktführer wie Neo4j bieten eine breite Unterstützung und Community, während spezialisierte Systeme für spezifische Anwendungsfälle die bessere Wahl sein können.

\pagebreak
\bibliographystyle{IEEEtran}
\bibliography{graphDB}

\end{document}